<!-- 파일 다운로드 -->
<%@page import="java.io.BufferedOutputStream"%>
<%@page import="java.io.BufferedInputStream"%>
<%@page import="java.net.URLEncoder"%>
<%@ page language="java" contentType="text/html; charset=EUC-KR" pageEncoding="EUC-KR"%>
<%@page import="myUtil.HanConv"%>
<%@page import="java.io.FileInputStream"%>
<%@page import="java.io.File"%>
	<%
		String filename = HanConv.toKor(request.getParameter("file_name"));
		String orgname = HanConv.toKor(request.getParameter("orgName"));
		
		String saveDirectory = "C:/upload/";
		String path = saveDirectory + File.separator + filename;
		
		System.out.println(path);
		
		File file = new File(path);
		long length = file.length();
		
		response.setContentType("application/octet-stream");
		
		response.setContentLength((int)length);
		
		boolean isIe = request.getHeader("user-agent").toUpperCase().indexOf("MSIE") != -1 ||
					   request.getHeader("user-agent").indexOf("11.0") != -1;
		if(isIe){ // 인터넷 익스플로러
			orgname = URLEncoder.encode(orgname,"UTF-8");
		}
		else{ 
			orgname = new String(orgname.getBytes("UTF-8"), "8859_1");
		}
		response.setHeader("Content-Disposition", "attachment;filename=" + orgname);
		BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));
			
		out.clear();
		out = pageContext.pushBody();
		BufferedOutputStream bos = new BufferedOutputStream(response.getOutputStream());
		
		int data;
		while((data=bis.read()) != -1){
			bos.write(data);
			bos.flush();
		}
		
		//8] 스트림 닫기
		bis.close();
		bos.close();
%>
<%-- <%
	// a태그의 href로  comm_File_Down.jsp?file_name="<%=fileName1 를 통해 
	// 전달한 중복 방지 처리한 파일명 값을 가져옴
	String fileName = request.getParameter("file_name");
	
	System.out.println(fileName);

	// 업로드한 폴더의 위치와 업로드 폴더의 이름을 알아야 함
	String savePath = "upload";
	// 위의 폴더는 상대경로, 절대경로 기준의 진짜 경로를 구해와야 함
	String sDownPath = request.getRealPath(savePath);
	
	System.out.println("다운로드 폴더 절대 경로 위치 >> " + sDownPath);
	System.out.println("fileName1 >> " + fileName);
	
	// 저장되어 있는 폴더경로 /저장된파일명 으로 풀 path 를 만들어줌
	// 자바에서는 \를 표시하기 위해서는 \를 한번 더 붙여주기 때문에 \\로 해줌
	String sFilePath = sDownPath + "\\" + fileName; // ex)c:\\uploat\\image.jpg
	System.out.println("sFilePath >> " + sFilePath);
	
	// 풀 path에 대한 걸 파일 객체로 인식시킴
	File outputFile = new File(sFilePath);
	// 저장된 파일을 일겅와 저장할 버퍼를 임시로 만들고 버퍼의 용량은 이전에 한번에 업로드 할 수 있는 파일 크기로 지정
	byte[] temp = new byte[1024*1024*10]; // 10M
	
	// 파일을 읽어와야 함으로 inputStream을 연다
	// (풀 패스를 가지는 파일 객체를 이용해 inputStream을 형성)
	FileInputStream in = new FileInputStream(outputFile);
	
	// 유형 확인 : 읽어올 경로의 파일의 유형 -> 페이지 생성할 때 타입을 설정
	String sMimeType = getServletContext().getMimeType(sFilePath);
	
	System.out.println("유형 >> " + sMimeType);
	
	// 지정되지 않은 유형 예외처리
	if(sMimeType == null){
		// 관례적인 표현
		sMimeType = "application.octec-stream"; // 일련된 8bit 스트림 형식
		// 유형이 알려지지 않은 파일에 대한 읽기 형식 지정
	}
	
	// 파일 다운로드 시작
	// 유형을 지정해 준다
	response.setContentType(sMimeType); 
	// 응답할 페이지가 text/html; charset=utf-8을 파일 mime 타입으로 지정
			
	// 업로드 파일의 제목이 깨질 수 있으므로 인코딩
	String sEncoding = new String(fileName.getBytes("euc-kr"), "8859_1");
	// String B = "utf-8";
	// String sEncoding = URLEncoder.encode(A,B);
	
	// 기타 내용을 헤더에 올려야함
	// 기타 내용을 보고 브라우저에서 다운로드시 화면에 출력시켜 줌
	String AA = "Content-Disposition";
	String BB = "attachment;filename=" + sEncoding;
	response.setHeader(AA, BB);
	
	// 브라우저에 쓰기
	ServletOutputStream out2 = response.getOutputStream();
	
	int numRead = 0;
	
	// 바이트 배열 temp의 0번째 부터 numRead 번까지 브라우저로 출력
	// 파일이 위치한 곳에 연결된 inputStream에서 읽되, 끝(-1) 전까지 while을 돔
	while((numRead = in.read(temp, 0, temp.length)) != -1){
		// temp 배열에 읽어오는데 0번째 인덱스부터 한번에 최대 temp.length만큼 읽어옴
		// 읽어올게 더이상 없으면 -1을 리턴하면서 while문을 빠져나감
		
		// 브라우저에 출력 : header정보를 attachment로 해 놓았으므로 다운로드가 됨
		out2.write(temp, 0, numRead);
		// temp배열에 있는 데이터의 0번째부터 최대 numRead만큼 출력
	}
	
	// 자원 해제
	out2.flush();
	out2.close();
	in.close();
%> --%>
